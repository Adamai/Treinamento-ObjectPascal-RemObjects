unit NewLibrary_Intf;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {$IFDEF DELPHIXE2UP}
    System.SysUtils, System.Classes, System.TypInfo,
  {$ELSE}
    SysUtils, Classes, TypInfo,
  {$ENDIF}
  {RemObjects:} uROUri, uROProxy, uROExceptions, uROXMLIntf, uROClasses, uROTypes, uROClientIntf;

const
  { Library ID }
  LibraryUID = '{60C5494A-F792-4B3E-8BE4-7A4857E996AF}';
  TargetNamespace = '';

  { Service Interface ID's }
  INewService_IID : TGUID = '{A3349381-5D0A-456D-B691-9BBC85F4A25D}';

type
  { Forward declarations }
  INewService = interface;

  ArrayAdmin = class;
  ArraySpeciality = class;

  admingroup = class;
  speciality = class;

  { Enumerateds }
  comandosADM = (
    AdmCMDDetalhes,
    AdmCMDInserir,
    AdmCMDAlterar,
    AdmCMDExcluir
  );

  comandosSpec = (
    specCMDDetalhes,
    specCMDAlterar,
    specCMDInserir,
    specCMDExcluir
  );

  {$IFDEF DELPHI10UP}{$REGION 'Structs'}{$ENDIF}
  { admingroup }
  admingroup = class(TROComplexType)
  private
    fid: Utf8String;
    fdescription: Utf8String;
    fcomando: comandosADM;
  public
    procedure Assign(iSource: TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
  published
    property id:Utf8String read fid write fid;
    property description:Utf8String read fdescription write fdescription;
    property comando:comandosADM read fcomando write fcomando;
  end;

  { admingroupCollection }
  admingroupCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(aIndex: Integer): admingroup;
    procedure SetItems(aIndex: Integer; const Value: admingroup);
  public
    constructor Create; overload;
    function Add: admingroup; reintroduce;
    procedure SaveToArray(anArray: ArrayAdmin);
    procedure LoadFromArray(anArray: ArrayAdmin);
    property Items[Index: Integer]:admingroup read GetItems write SetItems; default;
  end;

  { speciality }
  speciality = class(TROComplexType)
  private
    fid: Utf8String;
    fdescription: Utf8String;
    fflag_funcao_oper: Boolean;
    fcodg_admingroup_fk: Utf8String;
    fcomando: comandosSpec;
  public
    procedure Assign(iSource: TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
  published
    property id:Utf8String read fid write fid;
    property description:Utf8String read fdescription write fdescription;
    property flag_funcao_oper:Boolean read fflag_funcao_oper write fflag_funcao_oper;
    property codg_admingroup_fk:Utf8String read fcodg_admingroup_fk write fcodg_admingroup_fk;
    property comando:comandosSpec read fcomando write fcomando;
  end;

  { specialityCollection }
  specialityCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(aIndex: Integer): speciality;
    procedure SetItems(aIndex: Integer; const Value: speciality);
  public
    constructor Create; overload;
    function Add: speciality; reintroduce;
    procedure SaveToArray(anArray: ArraySpeciality);
    procedure LoadFromArray(anArray: ArraySpeciality);
    property Items[Index: Integer]:speciality read GetItems write SetItems; default;
  end;
  {$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

  {$IFDEF DELPHI10UP}{$REGION 'Arrays'}{$ENDIF}
  { ArrayAdmin }
  ArrayAdminEnumerator = class;
  ArrayAdmin_admingroup = array of admingroup;
  ArrayAdmin = class(TROArray)
  private
    fCount: Integer;
    fItems : ArrayAdmin_admingroup;
  protected
    procedure Grow; virtual;
    function GetItems(aIndex: Integer): admingroup;
    procedure SetItems(aIndex: Integer; const Value: admingroup);
    function GetCount: Integer; override;
  public
    class function GetItemType: PTypeInfo; override;
    class function GetItemClass: System.TClass; override;
    class function GetItemSize: Integer; override;

    function GetItemRef(aIndex: Integer): pointer; override;
    procedure SetItemRef(aIndex: Integer; Ref: pointer); override;
    procedure Clear; override;
    procedure Delete(aIndex: Integer); override;
    procedure Resize(ElementCount: Integer); override;

    procedure Assign(iSource:TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
    function Add: admingroup; overload;
    function Add(const Value: admingroup):Integer; overload;
    function GetEnumerator: ArrayAdminEnumerator;

    property Count : Integer read GetCount;
    property Items[Index: Integer]:admingroup read GetItems write SetItems; default;
    property InnerArray: ArrayAdmin_admingroup read fItems;
  end;

  ArrayAdminEnumerator = class
  private
    fArray: ArrayAdmin;
    fCurrentIndex: Integer;
    function GetCurrent: admingroup;
  public
    constructor Create(const AArray: ArrayAdmin);
    function MoveNext: Boolean;
    property Current: admingroup read GetCurrent;
  end;

  { ArraySpeciality }
  ArraySpecialityEnumerator = class;
  ArraySpeciality_speciality = array of speciality;
  ArraySpeciality = class(TROArray)
  private
    fCount: Integer;
    fItems : ArraySpeciality_speciality;
  protected
    procedure Grow; virtual;
    function GetItems(aIndex: Integer): speciality;
    procedure SetItems(aIndex: Integer; const Value: speciality);
    function GetCount: Integer; override;
  public
    class function GetItemType: PTypeInfo; override;
    class function GetItemClass: System.TClass; override;
    class function GetItemSize: Integer; override;

    function GetItemRef(aIndex: Integer): pointer; override;
    procedure SetItemRef(aIndex: Integer; Ref: pointer); override;
    procedure Clear; override;
    procedure Delete(aIndex: Integer); override;
    procedure Resize(ElementCount: Integer); override;

    procedure Assign(iSource:TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
    function Add: speciality; overload;
    function Add(const Value: speciality):Integer; overload;
    function GetEnumerator: ArraySpecialityEnumerator;

    property Count : Integer read GetCount;
    property Items[Index: Integer]:speciality read GetItems write SetItems; default;
    property InnerArray: ArraySpeciality_speciality read fItems;
  end;

  ArraySpecialityEnumerator = class
  private
    fArray: ArraySpeciality;
    fCurrentIndex: Integer;
    function GetCurrent: speciality;
  public
    constructor Create(const AArray: ArraySpeciality);
    function MoveNext: Boolean;
    property Current: speciality read GetCurrent;
  end;
  {$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

  {$IFDEF DELPHI10UP}{$REGION 'Services'}{$ENDIF}
  { INewService }
  INewService = interface
    ['{A3349381-5D0A-456D-B691-9BBC85F4A25D}']
    function Sum(const A: Integer; const B: Integer): Integer;
    function GetServerTime: DateTime;
    function carregarSpeciality(const id: Utf8String): speciality;
    function CarregarAdmingroup(const id: Utf8String): admingroup;
    function pesquisarSpeciality(const especialidade: Utf8String; const OS: Utf8String): ArraySpeciality;
    function pesquisarAdmin(const descricao: Utf8String; const OS: Utf8String): ArrayAdmin;
    procedure excluirAdmingroup(const id: Utf8String);
    procedure AlterarAdmingroup(const description: Utf8String; const id: Utf8String);
    function inserirAdmingroup(const id: Utf8String; const description: Utf8String): Boolean;
    function inserirSpeciality(const id: Utf8String; const description: Utf8String; const flag: Boolean; const admingroup: Utf8String): Boolean;
    procedure alterarSpeciality(const description: Utf8String; const flag: Boolean; const admingroup: Utf8String; const id: Utf8String);
    procedure excluirSpeciality(const id: Utf8String);
    function ListaSpeciality: ArraySpeciality;
    function ListaAdminGroup: ArrayAdmin;
  end;

  { CoNewService }
  CoNewService = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService; overload;
    class function Create(const aUri: TROUri): INewService; overload;
    class function Create(const aUrl: string): INewService; overload;
  end;

  { TNewService_Proxy }
  TNewService_Proxy = class(TROProxy, INewService)
  protected
    function __GetInterfaceName:string; override;

    function Sum(const A: Integer; const B: Integer): Integer;
    function GetServerTime: DateTime;
    function carregarSpeciality(const id: Utf8String): speciality;
    function CarregarAdmingroup(const id: Utf8String): admingroup;
    function pesquisarSpeciality(const especialidade: Utf8String; const OS: Utf8String): ArraySpeciality;
    function pesquisarAdmin(const descricao: Utf8String; const OS: Utf8String): ArrayAdmin;
    procedure excluirAdmingroup(const id: Utf8String);
    procedure AlterarAdmingroup(const description: Utf8String; const id: Utf8String);
    function inserirAdmingroup(const id: Utf8String; const description: Utf8String): Boolean;
    function inserirSpeciality(const id: Utf8String; const description: Utf8String; const flag: Boolean; const admingroup: Utf8String): Boolean;
    procedure alterarSpeciality(const description: Utf8String; const flag: Boolean; const admingroup: Utf8String; const id: Utf8String);
    procedure excluirSpeciality(const id: Utf8String);
    function ListaSpeciality: ArraySpeciality;
    function ListaAdminGroup: ArrayAdmin;
  end;
  {$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

implementation

uses
  {RemObjects:} uROEventReceiver, uROSerializer, uROClient, uRORes;

{$IFDEF DELPHI10UP}{$REGION 'ArrayAdmin'}{$ENDIF}
{ ArrayAdmin }
procedure ArrayAdmin.Assign(iSource: TPersistent);
var
  lSource: ArrayAdmin;
  i: Integer;
  lItem: admingroup;
begin
  if (iSource is ArrayAdmin) then begin
    lSource := ArrayAdmin(iSource);
    Self.Clear();

    for i := 0 to lSource.Count-1 do
      if System.Assigned(lSource.Items[i]) then begin
        lItem := admingroup(lSource.Items[i].ClassType.Create);
        lItem.Assign(lSource.Items[i]);
        Self.Add(lItem);
      end
      else begin
        Self.Add(nil);
      end;
  end
  else begin
    inherited Assign(iSource);
  end;
end;

function ArrayAdmin.GetEnumerator: ArrayAdminEnumerator;
begin
  Result := ArrayAdminEnumerator.Create(Self);
end;

class function ArrayAdmin.GetItemType: PTypeInfo;
begin
  Result := System.TypeInfo(admingroup);
end;

class function ArrayAdmin.GetItemClass: System.TClass;
begin
  Result := admingroup;
end;

class function ArrayAdmin.GetItemSize: Integer;
begin
  Result := System.SizeOf(admingroup);
end;

function ArrayAdmin.GetItems(aIndex: Integer): admingroup;
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  Result := fItems[aIndex];
end;

function ArrayAdmin.GetItemRef(aIndex: Integer): pointer;
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  Result := fItems[aIndex];
end;

procedure ArrayAdmin.SetItemRef(aIndex: Integer; Ref: pointer);
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  if Ref <> fItems[aIndex] then begin
    if fItems[aIndex] <> nil then fItems[aIndex].Free;
    fItems[aIndex] := Ref;
  end;
end;

procedure ArrayAdmin.Clear;
var i: Integer;
begin
  for i := 0 to (Self.Count-1) do fItems[i].Free();
  System.SetLength(fItems, 0);
  FCount := 0;
end;

procedure ArrayAdmin.Delete(aIndex: Integer);
var
  i: Integer;
begin
  if (aIndex >= Self.Count) then uROClasses.RaiseError(err_InvalidIndex, [aIndex]);

  fItems[aIndex].Free;

  if (aIndex < Self.Count-1) then
    for i := aIndex to Self.Count-2 do fItems[i] := fItems[i+1];

  System.SetLength(fItems, Self.Count-1);
  System.Dec(FCount);
end;

procedure ArrayAdmin.SetItems(aIndex: Integer; const Value: admingroup);
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  if fItems[aIndex] <> Value then begin
    fItems[aIndex].Free;
    fItems[aIndex] := Value;
  end;
end;

procedure ArrayAdmin.Resize(ElementCount: Integer);
var
  i: Integer;
begin
  if fCount = ElementCount then Exit;
  for i := FCount -1 downto ElementCount do
    FItems[i].Free;
  System.SetLength(fItems, ElementCount);
  for i := FCount to ElementCount -1 do
    FItems[i] := admingroup.Create;
  FCount := ElementCount;
end;

function ArrayAdmin.GetCount: Integer;
begin
  Result := FCount;
end;

procedure ArrayAdmin.Grow;
var
  lDelta, lCapacity: Integer;
begin
  lCapacity := System.Length(fItems);
  if lCapacity > 64 then
    lDelta := lCapacity div 4
  else
    if lCapacity > 8 then
      lDelta := 16
   else
      lDelta := 4;
  System.SetLength(fItems, lCapacity + lDelta);
end;

function ArrayAdmin.Add: admingroup;
begin
  Result := admingroup.Create;
  Self.Add(Result);
end;

function ArrayAdmin.Add(const Value:admingroup): Integer;
begin
  Result := Self.Count;
  if System.Length(fItems) = Result then
    Self.Grow;
  fItems[Result] := Value;
  System.Inc(fCount);
end;

procedure ArrayAdmin.ReadComplex(ASerializer: TObject);
var
  lval: admingroup;
  i: Integer;
begin
  for i := 0 to Self.Count-1 do begin
      TROSerializer(ASerializer).ReadStruct(TROSerializer(ASerializer).GetArrayElementName(GetItemType, GetItemRef(i)), admingroup, lval, i);
    Self.Items[i] := lval;
  end;
end;

procedure ArrayAdmin.WriteComplex(ASerializer: TObject);
var
  i: Integer;
begin
  TROSerializer(ASerializer).ChangeClass(ArrayAdmin);
  for i := 0 to Self.Count-1 do
      TROSerializer(ASerializer).WriteStruct(TROSerializer(ASerializer).GetArrayElementName(GetItemType, GetItemRef(i)), fItems[i], admingroup, i);
end;
{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

{$IFDEF DELPHI10UP}{$REGION 'ArrayAdminEnumerator'}{$ENDIF}
{ ArrayAdminEnumerator }
constructor ArrayAdminEnumerator.Create(const AArray: ArrayAdmin);
begin
  inherited Create;
  fArray := aArray;
  fCurrentIndex := -1;
end;

function ArrayAdminEnumerator.GetCurrent:admingroup;
begin
  Result := fArray.Items[fCurrentIndex];
end;

function ArrayAdminEnumerator.MoveNext: Boolean;
begin
  Result := fCurrentIndex < fArray.Count-1;
  if Result then Inc(fCurrentIndex);
end;

{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

{$IFDEF DELPHI10UP}{$REGION 'ArraySpeciality'}{$ENDIF}
{ ArraySpeciality }
procedure ArraySpeciality.Assign(iSource: TPersistent);
var
  lSource: ArraySpeciality;
  i: Integer;
  lItem: speciality;
begin
  if (iSource is ArraySpeciality) then begin
    lSource := ArraySpeciality(iSource);
    Self.Clear();

    for i := 0 to lSource.Count-1 do
      if System.Assigned(lSource.Items[i]) then begin
        lItem := speciality(lSource.Items[i].ClassType.Create);
        lItem.Assign(lSource.Items[i]);
        Self.Add(lItem);
      end
      else begin
        Self.Add(nil);
      end;
  end
  else begin
    inherited Assign(iSource);
  end;
end;

function ArraySpeciality.GetEnumerator: ArraySpecialityEnumerator;
begin
  Result := ArraySpecialityEnumerator.Create(Self);
end;

class function ArraySpeciality.GetItemType: PTypeInfo;
begin
  Result := System.TypeInfo(speciality);
end;

class function ArraySpeciality.GetItemClass: System.TClass;
begin
  Result := speciality;
end;

class function ArraySpeciality.GetItemSize: Integer;
begin
  Result := System.SizeOf(speciality);
end;

function ArraySpeciality.GetItems(aIndex: Integer): speciality;
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  Result := fItems[aIndex];
end;

function ArraySpeciality.GetItemRef(aIndex: Integer): pointer;
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  Result := fItems[aIndex];
end;

procedure ArraySpeciality.SetItemRef(aIndex: Integer; Ref: pointer);
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  if Ref <> fItems[aIndex] then begin
    if fItems[aIndex] <> nil then fItems[aIndex].Free;
    fItems[aIndex] := Ref;
  end;
end;

procedure ArraySpeciality.Clear;
var i: Integer;
begin
  for i := 0 to (Self.Count-1) do fItems[i].Free();
  System.SetLength(fItems, 0);
  FCount := 0;
end;

procedure ArraySpeciality.Delete(aIndex: Integer);
var
  i: Integer;
begin
  if (aIndex >= Self.Count) then uROClasses.RaiseError(err_InvalidIndex, [aIndex]);

  fItems[aIndex].Free;

  if (aIndex < Self.Count-1) then
    for i := aIndex to Self.Count-2 do fItems[i] := fItems[i+1];

  System.SetLength(fItems, Self.Count-1);
  System.Dec(FCount);
end;

procedure ArraySpeciality.SetItems(aIndex: Integer; const Value: speciality);
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  if fItems[aIndex] <> Value then begin
    fItems[aIndex].Free;
    fItems[aIndex] := Value;
  end;
end;

procedure ArraySpeciality.Resize(ElementCount: Integer);
var
  i: Integer;
begin
  if fCount = ElementCount then Exit;
  for i := FCount -1 downto ElementCount do
    FItems[i].Free;
  System.SetLength(fItems, ElementCount);
  for i := FCount to ElementCount -1 do
    FItems[i] := speciality.Create;
  FCount := ElementCount;
end;

function ArraySpeciality.GetCount: Integer;
begin
  Result := FCount;
end;

procedure ArraySpeciality.Grow;
var
  lDelta, lCapacity: Integer;
begin
  lCapacity := System.Length(fItems);
  if lCapacity > 64 then
    lDelta := lCapacity div 4
  else
    if lCapacity > 8 then
      lDelta := 16
   else
      lDelta := 4;
  System.SetLength(fItems, lCapacity + lDelta);
end;

function ArraySpeciality.Add: speciality;
begin
  Result := speciality.Create;
  Self.Add(Result);
end;

function ArraySpeciality.Add(const Value:speciality): Integer;
begin
  Result := Self.Count;
  if System.Length(fItems) = Result then
    Self.Grow;
  fItems[Result] := Value;
  System.Inc(fCount);
end;

procedure ArraySpeciality.ReadComplex(ASerializer: TObject);
var
  lval: speciality;
  i: Integer;
begin
  for i := 0 to Self.Count-1 do begin
      TROSerializer(ASerializer).ReadStruct(TROSerializer(ASerializer).GetArrayElementName(GetItemType, GetItemRef(i)), speciality, lval, i);
    Self.Items[i] := lval;
  end;
end;

procedure ArraySpeciality.WriteComplex(ASerializer: TObject);
var
  i: Integer;
begin
  TROSerializer(ASerializer).ChangeClass(ArraySpeciality);
  for i := 0 to Self.Count-1 do
      TROSerializer(ASerializer).WriteStruct(TROSerializer(ASerializer).GetArrayElementName(GetItemType, GetItemRef(i)), fItems[i], speciality, i);
end;
{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

{$IFDEF DELPHI10UP}{$REGION 'ArraySpecialityEnumerator'}{$ENDIF}
{ ArraySpecialityEnumerator }
constructor ArraySpecialityEnumerator.Create(const AArray: ArraySpeciality);
begin
  inherited Create;
  fArray := aArray;
  fCurrentIndex := -1;
end;

function ArraySpecialityEnumerator.GetCurrent:speciality;
begin
  Result := fArray.Items[fCurrentIndex];
end;

function ArraySpecialityEnumerator.MoveNext: Boolean;
begin
  Result := fCurrentIndex < fArray.Count-1;
  if Result then Inc(fCurrentIndex);
end;

{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

{$IFDEF DELPHI10UP}{$REGION 'admingroup'}{$ENDIF}
{ admingroup }
procedure admingroup.Assign(iSource: TPersistent);
var
  lSource: NewLibrary_Intf.admingroup;
begin
  inherited Assign(iSource);
  if (iSource is NewLibrary_Intf.admingroup) then begin
    lSource := NewLibrary_Intf.admingroup(iSource);

    Self.id := lSource.id;
    Self.description := lSource.description;
    Self.comando := lSource.comando;
  end;
end;

procedure admingroup.ReadComplex(ASerializer: TObject);
var
  l_comando: comandosADM;
  l_description: Utf8String;
  l_id: Utf8String;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    l_id := Self.id;
    try
      TROSerializer(ASerializer).ReadUTF8String('id', l_id);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'id']));
    end;
    Self.id := l_id;
    l_description := Self.description;
    try
      TROSerializer(ASerializer).ReadUTF8String('description', l_description);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'description']));
    end;
    Self.description := l_description;
    l_comando := Self.comando;
    try
      TROSerializer(ASerializer).ReadEnumerated('comando',System.TypeInfo(comandosADM), l_comando);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'comando']));
    end;
    Self.comando := l_comando;
  end
  else begin
    l_comando := Self.comando;
    try
      TROSerializer(ASerializer).ReadEnumerated('comando',System.TypeInfo(comandosADM), l_comando);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'comando']));
    end;
    Self.comando := l_comando;
    l_description := Self.description;
    try
      TROSerializer(ASerializer).ReadUTF8String('description', l_description);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'description']));
    end;
    Self.description := l_description;
    l_id := Self.id;
    try
      TROSerializer(ASerializer).ReadUTF8String('id', l_id);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'id']));
    end;
    Self.id := l_id;
  end;
end;

procedure admingroup.WriteComplex(ASerializer: TObject);
var
  l_comando: comandosADM;
  l_description: Utf8String;
  l_id: Utf8String;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    TROSerializer(ASerializer).ChangeClass(admingroup);
    l_id := Self.id;
    TROSerializer(ASerializer).WriteUTF8String('id', l_id);
    l_description := Self.description;
    TROSerializer(ASerializer).WriteUTF8String('description', l_description);
    l_comando := Self.comando;
    TROSerializer(ASerializer).WriteEnumerated('comando',System.TypeInfo(comandosADM), l_comando);
  end
  else begin
    l_comando := Self.comando;
    TROSerializer(ASerializer).WriteEnumerated('comando',System.TypeInfo(comandosADM), l_comando);
    l_description := Self.description;
    TROSerializer(ASerializer).WriteUTF8String('description', l_description);
    l_id := Self.id;
    TROSerializer(ASerializer).WriteUTF8String('id', l_id);
  end;
end;
{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

{$IFDEF DELPHI10UP}{$REGION 'admingroupCollection'}{$ENDIF}
{ admingroupCollection }
constructor admingroupCollection.Create;
begin
  inherited Create(admingroup);
end;

constructor admingroupCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function admingroupCollection.Add: admingroup;
begin
  Result := admingroup(inherited Add);
end;

function admingroupCollection.GetItems(aIndex: Integer): admingroup;
begin
  Result := admingroup(inherited Items[aIndex]);
end;

procedure admingroupCollection.LoadFromArray(anArray: ArrayAdmin);
var
  i : Integer;
begin
  Self.Clear;
  for i := 0 to (anArray.Count-1) do
    if anArray[i] <> nil then
      anArray[i].Clone.Collection := Self;
end;

procedure admingroupCollection.SaveToArray(anArray: ArrayAdmin);
var
  i : Integer;
begin
  anArray.Clear;
  for i := 0 to (Self.Count-1) do begin
    if System.Assigned(Self.Items[i]) then
      anArray.Add(admingroup(Self.Items[i].Clone))
    else
      anArray.Add(nil);
  end;
end;

procedure admingroupCollection.SetItems(aIndex: Integer; const Value: admingroup);
begin
  admingroup(inherited Items[aIndex]).Assign(Value);
end;
{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

{$IFDEF DELPHI10UP}{$REGION 'speciality'}{$ENDIF}
{ speciality }
procedure speciality.Assign(iSource: TPersistent);
var
  lSource: NewLibrary_Intf.speciality;
begin
  inherited Assign(iSource);
  if (iSource is NewLibrary_Intf.speciality) then begin
    lSource := NewLibrary_Intf.speciality(iSource);

    Self.id := lSource.id;
    Self.description := lSource.description;
    Self.flag_funcao_oper := lSource.flag_funcao_oper;
    Self.codg_admingroup_fk := lSource.codg_admingroup_fk;
    Self.comando := lSource.comando;
  end;
end;

procedure speciality.ReadComplex(ASerializer: TObject);
var
  l_codg_admingroup_fk: Utf8String;
  l_comando: comandosSpec;
  l_description: Utf8String;
  l_flag_funcao_oper: Boolean;
  l_id: Utf8String;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    l_id := Self.id;
    try
      TROSerializer(ASerializer).ReadUTF8String('id', l_id);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'id']));
    end;
    Self.id := l_id;
    l_description := Self.description;
    try
      TROSerializer(ASerializer).ReadUTF8String('description', l_description);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'description']));
    end;
    Self.description := l_description;
    l_flag_funcao_oper := Self.flag_funcao_oper;
    try
      TROSerializer(ASerializer).ReadEnumerated('flag_funcao_oper',System.TypeInfo(boolean), l_flag_funcao_oper);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'flag_funcao_oper']));
    end;
    Self.flag_funcao_oper := l_flag_funcao_oper;
    l_codg_admingroup_fk := Self.codg_admingroup_fk;
    try
      TROSerializer(ASerializer).ReadUTF8String('codg_admingroup_fk', l_codg_admingroup_fk);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'codg_admingroup_fk']));
    end;
    Self.codg_admingroup_fk := l_codg_admingroup_fk;
    l_comando := Self.comando;
    try
      TROSerializer(ASerializer).ReadEnumerated('comando',System.TypeInfo(comandosSpec), l_comando);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'comando']));
    end;
    Self.comando := l_comando;
  end
  else begin
    l_codg_admingroup_fk := Self.codg_admingroup_fk;
    try
      TROSerializer(ASerializer).ReadUTF8String('codg_admingroup_fk', l_codg_admingroup_fk);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'codg_admingroup_fk']));
    end;
    Self.codg_admingroup_fk := l_codg_admingroup_fk;
    l_comando := Self.comando;
    try
      TROSerializer(ASerializer).ReadEnumerated('comando',System.TypeInfo(comandosSpec), l_comando);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'comando']));
    end;
    Self.comando := l_comando;
    l_description := Self.description;
    try
      TROSerializer(ASerializer).ReadUTF8String('description', l_description);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'description']));
    end;
    Self.description := l_description;
    l_flag_funcao_oper := Self.flag_funcao_oper;
    try
      TROSerializer(ASerializer).ReadEnumerated('flag_funcao_oper',System.TypeInfo(boolean), l_flag_funcao_oper);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'flag_funcao_oper']));
    end;
    Self.flag_funcao_oper := l_flag_funcao_oper;
    l_id := Self.id;
    try
      TROSerializer(ASerializer).ReadUTF8String('id', l_id);
    except
      on E: {$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Exception do
        uROClasses.RaiseError({$IFDEF DELPHIXE2UP}System.{$ENDIF}SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'id']));
    end;
    Self.id := l_id;
  end;
end;

procedure speciality.WriteComplex(ASerializer: TObject);
var
  l_codg_admingroup_fk: Utf8String;
  l_comando: comandosSpec;
  l_description: Utf8String;
  l_flag_funcao_oper: Boolean;
  l_id: Utf8String;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    TROSerializer(ASerializer).ChangeClass(speciality);
    l_id := Self.id;
    TROSerializer(ASerializer).WriteUTF8String('id', l_id);
    l_description := Self.description;
    TROSerializer(ASerializer).WriteUTF8String('description', l_description);
    l_flag_funcao_oper := Self.flag_funcao_oper;
    TROSerializer(ASerializer).WriteEnumerated('flag_funcao_oper',System.TypeInfo(boolean), l_flag_funcao_oper);
    l_codg_admingroup_fk := Self.codg_admingroup_fk;
    TROSerializer(ASerializer).WriteUTF8String('codg_admingroup_fk', l_codg_admingroup_fk);
    l_comando := Self.comando;
    TROSerializer(ASerializer).WriteEnumerated('comando',System.TypeInfo(comandosSpec), l_comando);
  end
  else begin
    l_codg_admingroup_fk := Self.codg_admingroup_fk;
    TROSerializer(ASerializer).WriteUTF8String('codg_admingroup_fk', l_codg_admingroup_fk);
    l_comando := Self.comando;
    TROSerializer(ASerializer).WriteEnumerated('comando',System.TypeInfo(comandosSpec), l_comando);
    l_description := Self.description;
    TROSerializer(ASerializer).WriteUTF8String('description', l_description);
    l_flag_funcao_oper := Self.flag_funcao_oper;
    TROSerializer(ASerializer).WriteEnumerated('flag_funcao_oper',System.TypeInfo(boolean), l_flag_funcao_oper);
    l_id := Self.id;
    TROSerializer(ASerializer).WriteUTF8String('id', l_id);
  end;
end;
{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

{$IFDEF DELPHI10UP}{$REGION 'specialityCollection'}{$ENDIF}
{ specialityCollection }
constructor specialityCollection.Create;
begin
  inherited Create(speciality);
end;

constructor specialityCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function specialityCollection.Add: speciality;
begin
  Result := speciality(inherited Add);
end;

function specialityCollection.GetItems(aIndex: Integer): speciality;
begin
  Result := speciality(inherited Items[aIndex]);
end;

procedure specialityCollection.LoadFromArray(anArray: ArraySpeciality);
var
  i : Integer;
begin
  Self.Clear;
  for i := 0 to (anArray.Count-1) do
    if anArray[i] <> nil then
      anArray[i].Clone.Collection := Self;
end;

procedure specialityCollection.SaveToArray(anArray: ArraySpeciality);
var
  i : Integer;
begin
  anArray.Clear;
  for i := 0 to (Self.Count-1) do begin
    if System.Assigned(Self.Items[i]) then
      anArray.Add(speciality(Self.Items[i].Clone))
    else
      anArray.Add(nil);
  end;
end;

procedure specialityCollection.SetItems(aIndex: Integer; const Value: speciality);
begin
  speciality(inherited Items[aIndex]).Assign(Value);
end;
{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

{$IFDEF DELPHI10UP}{$REGION 'NewService'}{$ENDIF}
{ CoNewService }
class function CoNewService.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService;
begin
  Result := TNewService_Proxy.Create(aMessage, aTransportChannel);
end;

class function CoNewService.Create(const aUri: TROUri): INewService;
begin
  Result := TNewService_Proxy.Create(aUri);
end;

class function CoNewService.Create(const aUrl: string): INewService;
begin
  Result := TNewService_Proxy.Create(aUrl);
end;

{ TNewService_Proxy }
function TNewService_Proxy.__GetInterfaceName:string;
begin
  Result := 'NewService';
end;

function TNewService_Proxy.Sum(const A: Integer; const B: Integer): Integer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'Sum');
    lMessage.Write('A', System.TypeInfo(Integer), A, []);
    lMessage.Write('B', System.TypeInfo(Integer), B, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(Integer), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.GetServerTime: DateTime;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'GetServerTime');
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(DateTime), Result, [paIsDateTime]);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.carregarSpeciality(const id: Utf8String): speciality;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'carregarSpeciality');
    lMessage.Write('id', System.TypeInfo(Utf8String), id, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(NewLibrary_Intf.speciality), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.CarregarAdmingroup(const id: Utf8String): admingroup;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'CarregarAdmingroup');
    lMessage.Write('id', System.TypeInfo(Utf8String), id, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(NewLibrary_Intf.admingroup), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.pesquisarSpeciality(const especialidade: Utf8String; const OS: Utf8String): ArraySpeciality;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'pesquisarSpeciality');
    lMessage.Write('especialidade', System.TypeInfo(Utf8String), especialidade, []);
    lMessage.Write('OS', System.TypeInfo(Utf8String), OS, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(NewLibrary_Intf.ArraySpeciality), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.pesquisarAdmin(const descricao: Utf8String; const OS: Utf8String): ArrayAdmin;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'pesquisarAdmin');
    lMessage.Write('descricao', System.TypeInfo(Utf8String), descricao, []);
    lMessage.Write('OS', System.TypeInfo(Utf8String), OS, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(NewLibrary_Intf.ArrayAdmin), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TNewService_Proxy.excluirAdmingroup(const id: Utf8String);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'excluirAdmingroup');
    lMessage.Write('id', System.TypeInfo(Utf8String), id, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TNewService_Proxy.AlterarAdmingroup(const description: Utf8String; const id: Utf8String);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'AlterarAdmingroup');
    lMessage.Write('description', System.TypeInfo(Utf8String), description, []);
    lMessage.Write('id', System.TypeInfo(Utf8String), id, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.inserirAdmingroup(const id: Utf8String; const description: Utf8String): Boolean;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'inserirAdmingroup');
    lMessage.Write('id', System.TypeInfo(Utf8String), id, []);
    lMessage.Write('description', System.TypeInfo(Utf8String), description, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(Boolean), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.inserirSpeciality(const id: Utf8String; const description: Utf8String; const flag: Boolean; const admingroup: Utf8String): Boolean;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'inserirSpeciality');
    lMessage.Write('id', System.TypeInfo(Utf8String), id, []);
    lMessage.Write('description', System.TypeInfo(Utf8String), description, []);
    lMessage.Write('flag', System.TypeInfo(Boolean), flag, []);
    lMessage.Write('admingroup', System.TypeInfo(Utf8String), admingroup, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(Boolean), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TNewService_Proxy.alterarSpeciality(const description: Utf8String; const flag: Boolean; const admingroup: Utf8String; const id: Utf8String);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'alterarSpeciality');
    lMessage.Write('description', System.TypeInfo(Utf8String), description, []);
    lMessage.Write('flag', System.TypeInfo(Boolean), flag, []);
    lMessage.Write('admingroup', System.TypeInfo(Utf8String), admingroup, []);
    lMessage.Write('id', System.TypeInfo(Utf8String), id, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

procedure TNewService_Proxy.excluirSpeciality(const id: Utf8String);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'excluirSpeciality');
    lMessage.Write('id', System.TypeInfo(Utf8String), id, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.ListaSpeciality: ArraySpeciality;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'ListaSpeciality');
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(NewLibrary_Intf.ArraySpeciality), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.ListaAdminGroup: ArrayAdmin;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'ListaAdminGroup');
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', System.TypeInfo(NewLibrary_Intf.ArrayAdmin), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;
{$IFDEF DELPHI10UP}{$ENDREGION}{$ENDIF}

initialization
  RegisterROClass(admingroup);
  RegisterROClass(speciality);
  RegisterROClass(ArrayAdmin);
  RegisterROClass(ArraySpeciality);
  RegisterProxyClass(INewService_IID, TNewService_Proxy);

  RegisterROEnum('comandosADM',System.TypeInfo(NewLibrary_Intf.comandosADM));
  RegisterEnumMapping('comandosADM', 'AdmCMDDetalhes', 'AdmCMDDetalhes');
  RegisterEnumMapping('comandosADM', 'AdmCMDInserir', 'AdmCMDInserir');
  RegisterEnumMapping('comandosADM', 'AdmCMDAlterar', 'AdmCMDAlterar');
  RegisterEnumMapping('comandosADM', 'AdmCMDExcluir', 'AdmCMDExcluir');
  RegisterROEnum('comandosSpec',System.TypeInfo(NewLibrary_Intf.comandosSpec));
  RegisterEnumMapping('comandosSpec', 'specCMDDetalhes', 'specCMDDetalhes');
  RegisterEnumMapping('comandosSpec', 'specCMDAlterar', 'specCMDAlterar');
  RegisterEnumMapping('comandosSpec', 'specCMDInserir', 'specCMDInserir');
  RegisterEnumMapping('comandosSpec', 'specCMDExcluir', 'specCMDExcluir');

finalization
  UnregisterROClass(admingroup);
  UnregisterROClass(speciality);
  UnregisterROClass(ArrayAdmin);
  UnregisterROClass(ArraySpeciality);
  UnregisterProxyClass(INewService_IID);

  UnRegisterEnumMappings('comandosADM');
  UnregisterROEnum('comandosADM');
  UnRegisterEnumMappings('comandosSpec');
  UnregisterROEnum('comandosSpec');
end.
